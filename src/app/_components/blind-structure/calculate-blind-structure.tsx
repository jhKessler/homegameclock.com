import { number } from "zod";

// --- Type definitions (assuming from your project structure) ---
interface BlindLevel {
  smallBlind: number;
  bigBlind: number;
  // ante is a potential addition, but not included in core logic per request
  ante?: number;
}

type Params = {
  startingStack: number;
  numberOfPlayers: number;
  targetTournamentDuration: number;
  levelDuration: number;
  smallestChip: number;
};


// --- Main calculation function ---

/**
 * Calculates an intelligent and smooth poker tournament blind structure.
 * The structure is generated by:
 * 1. Creating a "perfect" canonical blind list with a slow start, a smooth linear mid-game,
 * and a doubling end-game, reflecting standard poker practices.
 * 2. Intelligently selecting levels from this master list using an exponential curve
 * to perfectly match the target duration and end-game stack depth.
 *
 * @param {Params} params - The parameters for the tournament.
 * @returns {BlindLevel[]} An array of blind levels for the tournament.
 */
export function calculateBlindStructure({
  startingStack,
  numberOfPlayers,
  targetTournamentDuration,
  levelDuration,
  smallestChip
}: Params): BlindLevel[] {

  // --- Core Logic ---

  if (smallestChip <= 0 || levelDuration <= 0 || targetTournamentDuration <= 0 || startingStack <= 0) {
    return [];
  }

  // --- 1. Generate the "Perfect" Canonical Blind Structure ---
  const canonicalBlinds: number[] = [];
  let lastBlind = 0;

  const addBlind = (val: number) => {
    // Round to a whole number and ensure it's a new, larger blind level
    const rounded = Math.round(val);
    if (rounded > lastBlind) {
      canonicalBlinds.push(rounded);
      lastBlind = rounded;
    }
  };

  addBlind(smallestChip);

  // Phase A: Slow, common progression up to 100
  if (smallestChip <= 25) {
    addBlind(50);
    addBlind(75);
  }
  if (smallestChip <= 50) {
      addBlind(100);
  }
  
  // Phase B: Smooth, linear progression from 100 to 1000
  // e.g., 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000
  for (let i = Math.floor(lastBlind / 100) + 1; i <= 10; i++) {
    addBlind(i * 100);
  }

  // Phase C: Progression from 1000 to 10000 with intermediate steps
  // e.g., 1000, 1500, 2000, 3000, 4000, 5000...
  addBlind(1500);
  for (let i = 2; i <= 10; i++) {
      if (i === 2) addBlind(2000);
      else if (i === 3) addBlind(3000);
      else if (i === 5) addBlind(5000);
      else addBlind(i * 1000); // Add other major steps
  }

  // Phase D: High-level blinds, approaching doubling
  addBlind(15000);
  addBlind(20000);
  addBlind(30000);
  addBlind(50000);
  addBlind(100000);

  // Continue with doubling for very deep structures
  let currentHighBlind = 100000;
  const totalChips = startingStack * numberOfPlayers;
  while(currentHighBlind < totalChips) {
      currentHighBlind *= 2;
      addBlind(currentHighBlind);
  }


  // --- 2. Intelligently Select Levels to Fit the Duration ---
  const totalLevels = Math.ceil(targetTournamentDuration / levelDuration);

  // The final level of the tournament should have a blind where a starting stack is ~4 Big Blinds.
  const TARGET_STACK_IN_BBS_AT_END = 10 / numberOfPlayers;
  const targetEndBigBlind = startingStack / TARGET_STACK_IN_BBS_AT_END;
  const targetEndSmallBlind = targetEndBigBlind / 2;

  // Find the index in our canonical list that corresponds to this desired end-game state.
  let endIndex = canonicalBlinds.findIndex(b => b >= targetEndSmallBlind);
  if (endIndex === -1) {
    endIndex = canonicalBlinds.length - 1; // If target is off the charts, use the last possible level.
  }

  const startIndex = canonicalBlinds.indexOf(smallestChip);
  const finalBlinds = new Set<number>();

  for (let i = 0; i < totalLevels+6; i++) {
    // If there's only one level, or it's the last level, progress is 1 (100%)
    const progress = (totalLevels <= 1) ? 1 : i / (totalLevels - 1);
    
    // Find the corresponding index in our canonical list based on that smooth progress.
    const targetIndex = Math.floor(startIndex + (endIndex - startIndex) * progress);
    
    // Ensure the index is within the bounds of our canonical list
    const safeIndex = Math.min(canonicalBlinds.length - 1, targetIndex);
    finalBlinds.add(canonicalBlinds[safeIndex]!);
  }

  // Format the final structure
  return Array.from(finalBlinds).map(sb => ({
    smallBlind: sb,
    bigBlind: sb * 2,
  }));
}

